; Modifying this file:
; You should not modify this file except to make bugfixes or
; for other "maintenance".  If you want to make custom changes,
; you should create a new datadir subdirectory and copy this file
; into that directory, and then modify that copy.  Then use the
; command "rulesetdir <mysubdir>" in the server to have freeciv
; use your new customized file.

; Note that the freeciv AI may not cope well with anything more
; than minor changes.

[datafile]
description="Multiplayer game rules for Freeciv"
options="+Freeciv-ruleset-Devel-2014.September.14c"

[about]
; Ruleset name
name = _("Multiplayer ruleset")

; There`s no separate versioning in rulesets part of main freeciv distribution
;version = ""

; Description of the ruleset
description = _("\
You are playing Freeciv with rules designed for multiplayer gaming. \
The biggest differences from the classic ruleset are that trade routes \
are disabled, and that most wonders can be built once by each player, \
and affect only cities on the same continent. A full description of \
the differences can be found in README.ruleset_multiplayer.\
")

[options]
global_init_techs=""
global_init_buildings="Palace"

[civstyle]
; Value added to city pollution
base_pollution   = -20

; Cost in luxuries of making one citizen happier
happy_cost       = 2

; Cost in food of upkeeping a single citizen
food_cost        = 2

; Parameters used to generalize the calculation of city granary size:
;   if city_size <= num_inis:
;     city_granary_size = (granary_food_ini[city_size] * foodbox / 100)
;   if city_size > num_inis;
;     city_granary_size = (granary_food_ini[num_inis] +
;        granary_food_inc * (city_size - num_inis)) * foodbox / 100
granary_food_ini = 20
granary_food_inc = 10

; City center minimum outputs
min_city_center_food    = 1
min_city_center_shield  = 1
min_city_center_trade   = 0

; Square of initial city radius
init_city_radius_sq     = 5

; Square of initially visible radius (true distance).
init_vis_radius_sq	= 5

; A base bribe cost, modified heavily by other factors
base_bribe_cost  = 750

; Barbarian leader ransom in gold
ransom_gold      = 100

; Number of veteran levels lost when upgrading a unit
upgrade_veteran_loss     = 0

; Number of veteran levels lost when auto-upgrading a unit
autoupgrade_veteran_loss = 0

; Whether player gets to select which terrain improvement to pillage.
pillage_select           = TRUE

; Whether one can steal a tech for which prereqs are not known
tech_steal_allow_holes    = TRUE
; Whether one can get a tech for which prereqs are not known via
; diplomatic trading
tech_trade_allow_holes    = TRUE
; ...and whether one can lose a tech which is prereq for another known
; tech via trade, if techlost_donor is nonzero
tech_trade_loss_allow_holes = TRUE
; Whether one can get a tech for which prereqs are not known via
; parasite effect (Great Library)
tech_parasite_allow_holes = TRUE
; Whether one can lose a tech which is prereq for another known tech
; due to negative bulbs, if techlossforgiveness allows loss
tech_loss_allow_holes     = TRUE

; Whether civil war is possible at all
civil_war_enabled        = TRUE

; Comma separated list of things to happen, in addition to death
; of owner, when gameloss unit dies
; "CivilWar"   - Part of the empire remains, controlled by a new player
; "Barbarians" - Depending on if there`s also "CivilWar", all or part
;                or half of the dead players empire gets under barbarian
;                control.
; "Loot"       - Player who killed the gameloss unit gets loot:
;                Partial map, gold, techs, cities
gameloss_style           = ""

; Whether units may safely paradrop to transport on non-native terrain
paradrop_to_transport    = FALSE

; Method of paying unit and improvement gold upkeep
; "City" - The player`s total gold must be non-negative after paying upkeep
;          costs associated with each city. If for any city the player`s
;          gold is negative, random buildings in the city are sold off. If
;          the gold is still negative, then supported units with gold upkeep
;          are disbanded.
; "Mixed" - In the first step, the player`s total gold must be non-negative
;           after paying upkeep for all buildings within a city. If for any
;           city the player`s gold is negative, random buildings in the city
;           are sold off.
;           In the second step, gold upkeep for all units is paid in a lump
;           sum. If the player does not have enough gold, random units with
;           gold upkeep are disbanded.
; "Nation" - Gold upkeep for all buildings and units is paid in a lump sum
;            after all cities have been processed. If the player does not
;            have enough gold, random buildings from random cities are sold.
;            If still more gold is needed, then random units with gold
;            upkeep are disbanded.
gold_upkeep_style = "City"

[illness]
; Whether plagues (illness) are possible
illness_on = FALSE

; the base factor for illness (of percent)
illness_base_factor = 25

; minimum city size for illness
illness_min_size = 3

; factor for how much trading with a plagued city increases our city`s
; chance for plague (in percent)
illness_trade_infection = 0

; factor for how much pollution within a city increases its chance for
; plague (in percent)
illness_pollution_factor = 50

[incite_cost]
; city_incite_cost = total_factor * (city_size) * (base_incite_cost
;                      + (units_cost) * unit_factor
;                      + (improvements_cost) * improvement_factor)
;                    / ((distance to capital) * 100)
; See city_incite_cost() for more details
base_incite_cost = 10000
improvement_factor = 1
unit_factor = 2
total_factor = 10000

[global_unit_options]
; Shore landing style
;  FALSE - normal movement
;  TRUE  - (default) slow invasions by removing all
;          movement points from ground units moving
;          from ocean tile to land
slow_invasions = TRUE

[combat_rules]
; If tired_attack is set to TRUE, units that attack with less than a single
; move point (per move_fragments in terrain.ruleset) will have their attack
; power reduced accordingly. For instance, if move_fragments=3, a unit with
; 2/3 move points will have attack power 2/3 of normal.
; If this is set to FALSE units will attack with full strength even if they
; have only fractional moves left.
tired_attack = FALSE

; /* <-- avoid gettext warnings
;
; Action enablers:
;
; action               = the action to enable.
; actor_reqs           = requirements that apply to the actor.
; target_reqs          = requirements that apply to the target.
;
; README.actions lists the possible actions and their hard coded
; requirements. Note that an action may append some of its hard
; requirements to actor_reqs and target_reqs.
;
; An action enabler is active when its actor_reqs AND its target_reqs are
; satisfied.
;
; */ <-- avoid gettext warnings
[actionenabler_sabotage_city]
action = "Sabotage City"
actor_reqs    =
    { "type",   "name", "range", "present"
      "UnitFlag", "Diplomat", "Local", TRUE
      "DiplRel", "War", "Local", TRUE
      "UnitFlag", "Spy", "Local", FALSE
      "UnitState", "TransportDependent", "Local", FALSE
      "MinMoveFrags", "1", "Local", TRUE
    }

[actionenabler_sabotage_city_target]
action = "Targeted Sabotage City"
actor_reqs    =
    { "type",   "name", "range", "present"
      "DiplRel", "War", "Local", TRUE
      "UnitFlag", "Spy", "Local", TRUE
      "UnitState", "TransportDependent", "Local", FALSE
      "MinMoveFrags", "1", "Local", TRUE
    }

[actionenabler_establish_embassy]
action       = "Establish Embassy"
actor_reqs    =
    { "type",   "name", "range", "present"
      "UnitFlag", "Diplomat", "Local", TRUE
      "UnitState", "TransportDependent", "Local", FALSE
      "MinMoveFrags", "1", "Local", TRUE
    }
target_reqs  =
    { "type",   "name", "range", "present"
      "Nation", "Barbarian", "Player", FALSE
      "Nation", "Pirate", "Player", FALSE
    }

[actionenabler_investigate_city]
action       = "Investigate City"
actor_reqs    =
    { "type",   "name", "range", "present"
      "UnitFlag", "Diplomat", "Local", TRUE
      "UnitState", "TransportDependent", "Local", FALSE
      "MinMoveFrags", "1", "Local", TRUE
    }

[actionenabler_poison_city]
action = "Poison City"
actor_reqs    =
    { "type",   "name", "range", "present"
      "UnitFlag", "Spy", "Local", TRUE
      "DiplRel", "War", "Local", TRUE
      "UnitState", "TransportDependent", "Local", FALSE
      "MinMoveFrags", "1", "Local", TRUE
    }
target_reqs    =
    { "type",   "name", "range"
      "MinSize", "2", "City"
    }

[actionenabler_steal_tech_random]
action = "Steal Tech"
actor_reqs    =
    { "type",   "name", "range", "present"
      "UnitFlag", "Diplomat", "Local", TRUE
      "UnitFlag", "Spy", "Local", FALSE
      "UnitState", "TransportDependent", "Local", FALSE
      "MinMoveFrags", "1", "Local", TRUE
    }
target_reqs  =
    { "type",   "name", "range", "present"
      "Nation", "Barbarian", "Player", FALSE
      "Nation", "Pirate", "Player", FALSE
    }

[actionenabler_steal_tech_target]
action = "Targeted Steal Tech"
actor_reqs    =
    { "type",   "name", "range", "present"
      "UnitFlag", "Spy", "Local", TRUE
      "UnitState", "TransportDependent", "Local", FALSE
      "MinMoveFrags", "1", "Local", TRUE
    }
target_reqs  =
    { "type",   "name", "range", "present"
      "Nation", "Barbarian", "Player", FALSE
      "Nation", "Pirate", "Player", FALSE
    }

[actionenabler_incite_city]
action = "Incite City"
actor_reqs    =
    { "type",   "name", "range", "present"
      "UnitFlag", "Diplomat", "Local", TRUE
      "DiplRel", "Alliance", "Local", FALSE
      "DiplRel", "Team", "Local", FALSE
      "UnitState", "TransportDependent", "Local", FALSE
      "MinMoveFrags", "1", "Local", TRUE
    }
target_reqs  =
    { "type",   "name", "range", "present"
      "Gov", "Democracy", "Player", FALSE
      "Building", "Palace", "City", FALSE
    }

[actionenabler_bribe_unit]
action = "Bribe Unit"
actor_reqs    =
    { "type",   "name", "range", "present"
      "UnitFlag", "Diplomat", "Local", TRUE
      "DiplRel", "Alliance", "Local", FALSE
      "DiplRel", "Team", "Local", FALSE
      "UnitState", "TransportDependent", "Local", FALSE
      "MinMoveFrags", "1", "Local", TRUE
    }
target_reqs    =
    { "type",   "name", "range", "present"
      "UnitType", "Leader", "Local", FALSE
      "UnitType", "Barbarian Leader", "Local", FALSE
      "CityTile", "Center", "Local", FALSE
      "Gov", "Democracy", "Player", FALSE
      "MaxUnitsOnTile", "1", "Local", TRUE
    }

[actionenabler_sabotage_unit]
action = "Sabotage Unit"
actor_reqs    =
    { "type",   "name", "range", "present"
      "Unitflag", "Spy", "Local", TRUE
      "DiplRel", "War", "Local", TRUE
      "UnitState", "TransportDependent", "Local", FALSE
      "MinMoveFrags", "1", "Local", TRUE
    }
target_reqs    =
    { "type",   "name", "range", "present"
      "CityTile", "Center", "Local", FALSE
      "MinHitPoints", "2", "Local", TRUE
      "MaxUnitsOnTile", "1", "Local", TRUE
    }

[borders]
; Base border radius from city.
radius_sq_city = 17

; Border radius square increased by this amount / point of city size
size_effect    = 1

[research]
; Method of calculating technology costs
;   "Civ I|II"      - Civ (I|II) style. Every new tech add researchcost to
;                     cost of next tech.
;   "Classic"       - Cost of technology is:
;                       base_tech_cost * (1 + reqs) * sqrt(1 + reqs) / 2
;                     where reqs == number of requirement for tech, counted
;                     recursively.
;   "Classic+"      - Cost are read from tech.ruleset. Missing costs are
;                     generated by style "Classic".
;   "Experimental"  - Cost of technology is:
;                       base_tech_cost * (reqs^2 / (1 + sqrt(sqrt(reqs + 1)))
;                                         - 0.5)
;                     where reqs == number of requirement for tech, counted
;                     recursively.
;   "Experimental+" - Cost are read from tech.ruleset. Missing costs are
;                     generated by style "Experimental".
tech_cost_style = "Classic"

; Base research cost for tech styles 1 & 2
base_tech_cost   = 20

; Technology leak from other civilizations
; "None"           - No reduction of the technology cost.
; "Embassies"      - Technology cost is reduced depending on the number of
;                    players which already know the tech and you have an
;                    embassy with.
; "All Players"    - Technology cost is reduced depending on the number of
;                    all players (human, AI and barbarians) which already
;                    know the tech.
; "Normal Players" - Technology cost is reduced depending on the number of
;                    normal players (human and AI) which already know the
;                    tech.
tech_leakage = "None"

; Method of paying tech upkeep
; "None"   - no upkeep
; "Basic"  - upkeep is calculated as:
;     <Cost of technology> / tech_upkeep_divider - tech_upkeep_free
; "Cities" - upkeep is calculated like "Basic", but multiplied by number of cities
tech_upkeep_style = "None"

; upkeep cost is divided by this value
tech_upkeep_divider = 2000

; Method of selecting techs given for free
; "Goal"     - Towards player`s goal, random if no goal
; "Random"   - Random researchable tech
; "Cheapest" - Cheapest researchable tech, random among equal cost ones
free_tech_method = "Goal"

[culture]
; Minimum culture points for cultural domination victory
victory_min_points = 1000

; Lead needed relative to second best player
victory_lead_pct   = 300

; How much each culture point affects the migration
; from/to the city.
migration_pct = 50

[calendar]
; Year in the beginning of the game
start_year = -4000

; Year 1 instead of 0.
skip_year_0 = TRUE

; How many fragments each year has. Value 0 disables year advancement by fragment
; accumulation.
fragments = 0

; Calendar fragment names. If name is missing, only a fragment number +1 (so human readable
; numbers begin froá¸¿ 1 and not 0) is shown.

;fragment_name0 = "Jan"
;fragment_name1 = "Feb"
; ...

; What labels are used for positive and negative years.
; /* TRANS: year label (Common Era) */
positive_label = _("CE")
; /* TRANS: year label (Before Common Era) */
negative_label = _("BCE")

; /* <-- avoid gettext warnings
;
; Disaster types:
;
; name                    = translatable name as seen by user
; reqs                    = requirements for disaster to happen (see effects.ruleset
;                           and README.effects for help on requirements)
; frequency               = how likely disaster is to occur
; effects
;   - "DestroyBuilding"   = Random building is destroyed
;   - "ReducePopulation"  = Reduce city size by one unless it's already 1
;   - "ReducePopDestroy"  = Reduce city size by one, possibly destroying the city
;   - "EmptyFoodStock"    = Remove all food from food stock
;   - "EmptyProdStock"    = Destroy current production
;   - "Pollution"         = One tile surrounding city polluted
;   - "Fallout"           = One tile surrounding city polluted with fallout
;
; */ <-- avoid gettext warnings

; No disasters in multiplayer ruleset

; /* <-- avoid gettext warnings
;
; Achievement types:
;
; name                    = translatable name as seen by user
; rule_name               = (optional) name for savegames, rulesets etc; if not
;                           present, 'name' is used. Since the name used in
;                           savegames must not change, use this when renaming a
;                           achievement after a ruleset has been released.
; type                    = What event grants the achievement to player.
;                           See README.achievements for list of these types.
; unique                  = If TRUE, only first one reaching the achievement will
;                           get it. Defaults to TRUE.
; value                   = Value to reach. Exact meaning of this depends on
;                           achievement type.
; culture                 = Amount of culture granted to player who gets achievement
;                           granted.
; first_msg               = Message shown to first player gaining the achievement
; cons_msg                = Message shown to consecutive players gaining the achievement
;
; */ <-- avoid gettext warnings

; No achievements in multiplayer ruleset

;
; Trade settings
;
; IN = international, IC = intercontinental.
; For each of the trade route types:
; "pct"        - Trade income %. If this is 0, trade route cannot be
;                established at all
; "cancelling" - What to do to previously established traderoutes when they
;                turn illegal
;                "Active"   - Keep them active (although they will only
;                             provide nonzero income if illegal due to
;                             trademindist rather than pct==0)
;                "Inactive" - Keep them inactive
;                "Cancel"   - Cancel them altogether
; "bonus"      - One-time bonuses granted when traderoute established
;                "None"     - No one-time bonus
;                "Gold"     - Bonus to gold
;                "Science"  - Bonus to research
;                "Both"     - Bonus to gold and research
;
[trade]
settings =
  { "type",       "pct", "cancelling", "bonus"
    "National",   0,     "Cancel",     "Both"
    "NationalIC", 0,     "Cancel",     "Both"
    "IN",         0,     "Cancel",     "Both"
    "INIC",       0,     "Cancel",     "Both"
    "Ally",       0,     "Cancel",     "Both"
    "AllyIC",     0,     "Cancel",     "Both"
    "Enemy",      0,     "Cancel",     "Both"
    "EnemyIC",    0,     "Cancel",     "Both"
    "Team",       0,     "Cancel",     "Both"
    "TeamIC",     0,     "Cancel",     "Both"
  }

[playercolors]
background.r = 86
background.g = 86
background.b = 86

; Player colors for 32 players are defined below.
; Avoid greens, blues, and white / very pale colors (too easy to confuse
; with terrain).
; Avoid dark colors.
colorlist =
    { "r", "g", "b"
      255,   0,   0  ; Red
      255, 255,   0  ; Yellow
        0, 255, 255  ; Blue
      138,  43, 226  ; Purple
      255, 165,   0  ; Orange
      255,   0, 255  ; Magenta
      173, 216, 230  ; Cornflower
        0, 255, 127  ; Emerald
      250, 128, 114  ; Salmon
      124, 252,   0  ; Green
      139,   0,   0  ; Burgundy
      255, 192, 203  ; Pink
      211, 211, 211  ; Silver
      218, 112, 214  ; Heliotrope
      255,  20, 147  ; Fuchsia
      100, 149, 237  ; Azure
      255, 215,   0  ; Gold
      245, 222, 179  ; Khaki
      255, 255, 128  ; Butter
      192, 255, 128  ; Mint
      204, 255,   0  ; Lime
      255, 211, 140  ; Peach
      255,  79,   0  ; Vermilion
      240, 145, 169  ; Puce
      255, 219,  88  ; Mustard
      153,  17, 153  ; Aubergine
      184, 134,  11  ; Brown
      255, 102,   0  ; Pumpkin
      102, 205, 170  ; Turquoise
      195,  33,  72  ; Crimson
      168, 153, 230  ; Lavender
      255, 250, 205  ; Cream
    }

[teams]
; Team names correspond roughly to colors defined above, so that
; plrcolormode=TEAM_ORDER is not gratuitously confusing.
names =
; /* TRANS: Name of a color; used as unique identifier for a team */
; /* TRANS: With this and other color team names, uniqueness is more */
; /* TRANS: important than precise translation. To see the colors, start a */
; /* TRANS: multiplayer game with 32 players and look at the Nations report. */
 _("?team name:Red"),
; /* TRANS: Name of a color; used as unique identifier for a team */
 _("?team name:Yellow"),
; /* TRANS: Name of a color; used as unique identifier for a team */
 _("?team name:Blue"),
; /* TRANS: Name of a color; used as unique identifier for a team */
 _("?team name:Purple"),
; /* TRANS: Name of a color; used as unique identifier for a team */
 _("?team name:Orange"),
; /* TRANS: Name of a color; used as unique identifier for a team */
 _("?team name:Magenta"),
; /* TRANS: Name of a color; used as unique identifier for a team */
 _("?team name:Cornflower"),
; /* TRANS: Name of a color; used as unique identifier for a team */
 _("?team name:Emerald"),
; /* TRANS: Name of a color; used as unique identifier for a team */
 _("?team name:Salmon"),
; /* TRANS: Name of a color; used as unique identifier for a team */
 _("?team name:Green"),
; /* TRANS: Name of a color; used as unique identifier for a team */
 _("?team name:Burgundy"),
; /* TRANS: Name of a color; used as unique identifier for a team */
 _("?team name:Pink"),
; /* TRANS: Name of a color; used as unique identifier for a team */
 _("?team name:Silver"),
; /* TRANS: Name of a color; used as unique identifier for a team */
 _("?team name:Heliotrope"),
; /* TRANS: Name of a color; used as unique identifier for a team */
 _("?team name:Fuchsia"),
; /* TRANS: Name of a color; used as unique identifier for a team */
 _("?team name:Azure"),
; /* TRANS: Name of a color; used as unique identifier for a team */
 _("?team name:Gold"),
; /* TRANS: Name of a color; used as unique identifier for a team */
 _("?team name:Khaki"),
; /* TRANS: Name of a color; used as unique identifier for a team */
 _("?team name:Butter"),
; /* TRANS: Name of a color; used as unique identifier for a team */
 _("?team name:Mint"),
; /* TRANS: Name of a color; used as unique identifier for a team */
 _("?team name:Lime"),
; /* TRANS: Name of a color; used as unique identifier for a team */
 _("?team name:Peach"),
; /* TRANS: Name of a color; used as unique identifier for a team */
 _("?team name:Vermilion"),
; /* TRANS: Name of a color; used as unique identifier for a team */
 _("?team name:Puce"),
; /* TRANS: Name of a color; used as unique identifier for a team */
 _("?team name:Mustard"),
; /* TRANS: Name of a color; used as unique identifier for a team */
 _("?team name:Aubergine"),
; /* TRANS: Name of a color; used as unique identifier for a team */
 _("?team name:Brown"),
; /* TRANS: Name of a color; used as unique identifier for a team */
 _("?team name:Pumpkin"),
; /* TRANS: Name of a color; used as unique identifier for a team */
 _("?team name:Turquoise"),
; /* TRANS: Name of a color; used as unique identifier for a team */
 _("?team name:Crimson"),
; /* TRANS: Name of a color; used as unique identifier for a team */
 _("?team name:Lavender"),
; /* TRANS: Name of a color; used as unique identifier for a team */
 _("?team name:Cream")

[settings]
set =
    { "name", "value", "lock"
      "minplayers", 2, FALSE
      "generator", "ISLAND", FALSE
      "topology", "WRAPX|WRAPY|ISO", FALSE
      "startpos", "SINGLE", FALSE
      "tinyisles", FALSE, FALSE
      "alltemperate", TRUE, FALSE
      "separatepoles", FALSE, FALSE
      "huts", 0, FALSE
      "aifill", 0, FALSE
      "dispersion", 0, FALSE
      "diplomacy", "DISABLED", FALSE
      "contactturns", 0, FALSE
      "revolen", 2, FALSE
      "barbarians", "DISABLED", FALSE
      "techpenalty", 0, FALSE
      "startunits", "cccwwwxxxx", FALSE
      "specials", 350, FALSE
      "borders", "DISABLED", FALSE
    }
